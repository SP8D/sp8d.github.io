{"/api-reference/channel-api":{"title":"SP8D Channel API Reference: Lock-Free Messaging for JavaScript & Node.js","data":{"":"Access the comprehensive SP8D Channel API reference for JavaScript and Node.js. Learn methods, options, diagnostics, troubleshooting, and best practices for lock-free, real-time, high-performance messaging.\nThe Channel API is at the heart of SP8D: It gives you explicit, lock-free, slot-driven control over cross-thread messaging—plus direct access to real-time diagnostics, segmentation, and backpressure handling.","channel-creation#Channel Creation":"Create a channel for real-time, lock-free messaging. Use\ncreateChannel for new channels, attachChannel to\nconnect in another thread.","createchanneloptions--channel-buffer-#createChannel(options): { channel, buffer }":"Creates a new SP8D channel, returning both the API object and the underlying SharedArrayBuffer.Options:\nslots (number, required) — Number of slots in the ring buffer.\nslotSize (number, required) — Max size (bytes) per payload.\nmode (string: \"SPSC\" | \"MPSC\" | \"MPMC\", optional) — Concurrency mode. Default: \"SPSC\".\nsegments (number) — Segments for increased scale. Default: 1.\nsweepTimeoutMs (number) — Slot reclaim timeout (ms). Default: 50.\nconst { channel, buffer } = createChannel({\n  slots: 16,\n  slotSize: 64,\n  mode: \"MPMC\",\n  segments: 2,\n});","attachchannelbuffer-sharedarraybuffer-channel#attachChannel(buffer: SharedArrayBuffer): Channel":"","use-in-a-second-threadworker-to-attach-to-an-existing-channels-buffer#Use in a second thread/worker to attach to an existing channel’s buffer.":"// In a worker thread/process\nconst channel = attachChannel(buffer);","channel-api-core-methods#Channel API: Core Methods":"Methods are grouped by intent. Each group starts with a short intro and best\npractices. Scan, deep-dive, or jump to what you need.","send-data#Send Data":"Use trySend in high-frequency or non-critical paths to avoid\nexceptions. Use send when you must guarantee delivery or want to\ncatch errors.","sendpayload-arraybufferview-producerid-number-boolean#send(payload: ArrayBufferView, producerId?: number): boolean":"Enqueue a message. Throws if full or payload too large. Use for critical, must-succeed sends.","trysendpayload-arraybufferview-producerid-number-boolean#trySend(payload: ArrayBufferView, producerId?: number): boolean":"Enqueue a message. Returns false if full or payload too large—never throws. Use for non-blocking, best-effort sends.","sendasyncpayload-arraybufferview-producerid-number-opts-promiseboolean#sendAsync(payload: ArrayBufferView, producerId?: number, opts?): Promise<boolean>":"Waits for a slot and sends. Supports timeout and abort. Use for async, backpressure-aware flows.\nawait channel.sendAsync(msg, myProducerId, { timeoutMs: 1000 });","receive-data#Receive Data":"Use recvAsync for event-driven flows, and tryRecv\nfor polling or non-blocking loops.","recv-uint8array--null#recv(): Uint8Array | null":"Synchronous receive. Returns null if empty. Use for polling or tight loops.\nconst next = channel.recv();\nif (next) process(next);","tryrecv-uint8array--null#tryRecv(): Uint8Array | null":"Non-throwing, non-blocking receive. Returns null if empty.\nconst msg = channel.tryRecv();\nif (msg) process(msg);","recvasync-promiseuint8array--null#recvAsync(): Promise<Uint8Array | null>":"Async receive. Waits for a message. Use for event-driven or awaitable flows.\nconst msg = await channel.recvAsync();","json-helpers#JSON Helpers":"JSON helpers are for quick prototyping. For production, prefer binary\nserialization for performance and size.","sendjsonobj-object-producerid-number-boolean#sendJSON(obj: object, producerId?: number): boolean":"Send a JSON-serializable object. Throws if full or payload too large.","recvjson-object--null#recvJSON(): object | null":"Receive a JSON-serialized object. Returns null if empty or parse fails.","channel-state#Channel State":"Use full() and empty() to check channel status\nbefore sending or receiving in tight loops.","full-boolean#full(): boolean":"Returns true if the channel is full (no slots available for sending).","empty-boolean#empty(): boolean":"Returns true if the channel is empty (no slots available for reading).","lifecycle--control#Lifecycle & Control":"After close(), all send/recv methods will throw or return falsy.\nUse closeAsync for graceful shutdowns in async environments.","close-void#close(): void":"Immediately closes the channel and all internal timers. Cleans up, resets all state. After close(), send/recv throw or return falsy.","closeasync-promisevoid#closeAsync(): Promise<void>":"Gracefully closes the channel and waits for all background tasks to stop.\nawait channel.closeAsync();","reset-void#reset(): void":"Resets the channel to its initial state (empties all slots, resets counters). Does not reallocate the buffer.\nchannel.reset();","diagnostics--introspection#Diagnostics & Introspection":"The channel can be used as an async iterator for idiomatic, event-driven\nmessage consumption. Use stats() and info() for live\nmonitoring and debugging. Use validate() in tests to catch\nprotocol errors early.","stats-channelstats#stats(): ChannelStats":"Returns a snapshot object of channel usage and health metrics.\nslots — total slots\nused — slots in use\nfree — slots available\nerrors, conflicts, reclaimed — counts of errors, producer/consumer collisions, and recovery sweeps","info-string#info(): string":"Returns a human-readable string of the channel’s configuration (mode, size, segments).","validate-void#validate(): void":"Checks protocol invariants—throws if any slot is in an illegal state. Use in development/testing, not hot production loops.","symbolasynciterator-asynciteratoruint8array-void#[Symbol.asyncIterator](): AsyncIterator<Uint8Array, void>":"The channel can be used as an async iterator:\nfor await (const msg of channel) {\n  // receive messages until channel.close()\n}","advanced-slot-status-internals#Advanced: Slot Status Internals":"For a complete explanation of slot state machine internals—including slot lifecycle, state transitions, atomic operations, and recovery—see the Slot State Machine documentation.","diagnostics--observability#Diagnostics & Observability":"Use diagnostics in development and staging to catch protocol issues early.\nAvoid running diagnostics in hot production loops unless you need live\nmonitoring.\nimport { createChannelDiagnostics } from \"@sp8d/diagnostics\";\nconst diagnostics = createChannelDiagnostics(channel, 100);\ndiagnostics.onUpdate((stats) => {\n  console.log(\"SP8D Stats:\", stats);\n});\ndiagnostics.start();\nSee the Diagnostics Guide → for more.","troubleshooting#Troubleshooting":"Most issues stem from mismatched buffer sizes, incorrect slot counts, or using\nthe wrong concurrency mode. Double-check your channel creation options. Common\nissues are listed below.","common-issues--solutions#Common Issues & Solutions":"Problem: send or trySend always returns false or throws.\nSolution: Ensure the channel is not full. Check slotSize and payload size. For async flows, use sendAsync with a timeout.\nProblem: recv/tryRecv always returns null.\nSolution: The channel is empty. Confirm that producers are sending data and that you are not reading faster than writing.\nProblem: attachChannel throws or returns an unusable channel.\nSolution: Make sure the SharedArrayBuffer is valid and matches the expected structure (slots, slotSize, segments).\nProblem: Diagnostics report protocol errors or slot conflicts.\nSolution: Check that all threads use the correct concurrency mode (SPSC, MPSC, MPMC) and that no two producers/consumers are racing in SPSC mode.\nProblem: Channel appears to hang or deadlock.\nSolution: Avoid blocking the main thread. Use async methods and ensure all consumers/producers are running. For MPMC, ensure all parties are using unique IDs if required.","performance--concurrency-tips#Performance & Concurrency Tips":"For maximum throughput, tune slots and slotSize to\nmatch your message rate and payload size. Use the minimal number of segments\nneeded for your concurrency model.\nPrefer trySend/tryRecv in tight loops to avoid blocking.\nUse sendAsync/recvAsync for backpressure-aware, event-driven flows.\nIn high-concurrency scenarios, use the correct mode (MPSC or MPMC) and avoid sharing producer/consumer IDs.\nMonitor diagnostics in staging to catch contention or reclaim issues before production.\nAvoid frequent reset() in production; use it for test harnesses or controlled recovery only.\nFor lowest latency, keep sweepTimeoutMs low, but not zero—test for your workload.","where-to-go-next#Where to Go Next":"Common Recipes\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/examples/basic-spsc":{"title":"SP8D SPSC Example: Single-Producer Single-Consumer in JavaScript & Node.js","data":{"":"This page demonstrates a step-by-step SP8D SPSC (Single-Producer, Single-Consumer) example for JavaScript and Node.js. Learn how to implement ultra-low-latency, lock-free channels for high-performance messaging in your apps.The classic “lock-free queue” pattern—one producer, one consumer, highest throughput, zero overhead. SPSC is the fastest possible channel mode: no locks, no contention, and cache-friendly.\nSPSC (Single-Producer, Single-Consumer) channels are the gold standard for ultra-low-latency, lock-free communication between exactly two threads or tasks. Use this pattern when you need maximum throughput and absolute ordering, with zero contention or ambiguity.","minimal-spsc-example-nodejs-or-browser#Minimal SPSC Example (Node.js or Browser)":"This example walks you through the simplest SPSC channel: one producer, one\nconsumer, zero contention. Perfect for ultra-low-latency pipelines or thread\nhandoff. The diagram below shows the data flow.\nDiagram: Producer uses send() to move data to\nthe channel. Consumer uses recv() to receive it. This direct\nhandoff is what enables SPSC's ultra-low latency and simplicity.\nimport { createChannel } from \"@sp8d/core\";\n// Create an SPSC channel with 4 slots, each slot holding up to 16 bytes.\nconst { channel } = createChannel({ slots: 4, slotSize: 16, mode: \"SPSC\" });\n// Producer sends messages\nfor (let i = 0; i < 8; ++i) {\n  // Wait if channel is full (backpressure)\n  while (!channel.send(new Uint8Array([i, i * 10]))) {\n    // Buffer is full, so producer waits and retries (busy-wait)\n  }\n  console.log(\"Sent:\", i);\n}\n// Consumer receives messages\nlet received: Uint8Array | null;\nwhile ((received = channel.recv()) !== null) {\n  console.log(\"Received:\", received);\n}\nThe busy-wait loop (while (!send)) is for demonstration only. In\nproduction, use sendAsync() or a backpressure-aware event loop to\navoid wasting CPU cycles.","asyncreal-world-example#Async/Real-World Example":"For real-world, non-blocking usage, use sendAsync() and the async\niterator as shown below.\n// Producer (async)\nfor (let i = 0; i < 8; ++i) {\n  await channel.sendAsync(new Uint8Array([i, i * 10]));\n  console.log(\"Sent:\", i);\n}\n// Consumer (async)\nfor await (const received of channel) {\n  console.log(\"Received:\", received);\n}","whats-happening#What's happening?":"Producer: Calls send() in a loop—respects backpressure if the buffer is full.\nConsumer: Calls recv() repeatedly—gets every value, in order, with no races or drops.\nSPSC Mode Guarantee: Guarantees simple “ping-pong” correctness: no overwrites, slot loss, or ambiguity.\nBackpressure is critical for lossless, high-throughput systems. Notice the producer waits (while (!send)) if the ring is full. This ensures you never lose data—even under burst conditions.\nThe output below shows the expected send/receive order for this example. If\nyou run producer and consumer in separate threads, the interleaving may\ndiffer, but all messages will be delivered in order.\nSent: 0\nSent: 1\nSent: 2\nSent: 3\nReceived: Uint8Array([0, 0])\nReceived: Uint8Array([1, 10])\nReceived: Uint8Array([2, 20])\nReceived: Uint8Array([3, 30])\nSent: 4\nSent: 5\nSent: 6\nSent: 7\nReceived: Uint8Array([4, 40])\nReceived: Uint8Array([5, 50])\nReceived: Uint8Array([6, 60])\nReceived: Uint8Array([7, 70])\nsend() returns false when full; always check for\nbackpressure.\nrecv() returns null when channel is empty.\nFor browser use, producer and consumer may be in separate threads—see\nbrowser recipes.\nFor async use, see recvAsync() or the async iterator.\nIf you see dropped messages, check your slot count and backpressure\nhandling.\nFor debugging, use diagnostics or enable verbose logging.\nSPSC is the fastest mode, but only if you stick to the single-producer/single-consumer contract. If you break this contract, you may see data loss or protocol errors—use MPSC/MPMC for more complex patterns.","how-does-this-work-under-the-hood#How does this work under the hood?":"For a complete explanation of the slot state machine—including slot lifecycle, state transitions, atomic operations, and recovery—see the Slot State Machine documentation.","where-to-go-next#Where to Go Next":"Common Recipes\nChannel API Reference\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/examples/scalable-mpmc":{"title":"SP8D Example: Scalable MPMC (Placeholder)","data":{"":"Content coming soon."}},"/guides-and-howtos/faqs":{"title":"SP8D FAQ: Troubleshooting, Diagnostics & Concurrency in JavaScript & Node.js","data":{"":"Find answers to common SP8D questions about browser support, diagnostics, backpressure, async iteration, and troubleshooting for high-performance JavaScript and Node.js messaging.","sharedarraybuffer--browser-support#SharedArrayBuffer & Browser Support":"Q: Why do I get “Cannot use SharedArrayBuffer” or see errors about browser support?\nA: Your browser or environment may lack SharedArrayBuffer/Atomics support, or you may need special headers (COOP/COEP). See installation requirements.","diagnostics--live-monitoring#Diagnostics & Live Monitoring":"Q: How do I use diagnostics or monitor channel health?\nA: See the Protocol Internals: Architecture Overview for the canonical explanation of diagnostics, observability, and live monitoring in SP8D. For API usage, see the Channel API Reference.","backpressure--buffer-full#Backpressure & Buffer Full":"Q: What should I do if the channel is full or backpressured?\nA: See Fairness & Backpressure for the canonical, in-depth guide to backpressure, fairness, and buffer full handling in SP8D. This is the best resource for understanding and resolving these issues.","protocol-errors--debugging#Protocol Errors & Debugging":"Q: What do protocol errors or slot conflicts mean?\nA: See the Protocol Internals: Architecture Overview for protocol error handling, slot conflicts, and recovery mechanisms.","async-iteration--patterns#Async Iteration & Patterns":"Q: Can I use async iteration with channels?\nA: Yes, channels support async iteration for event-driven consumption.","broadcasting--mpmc#Broadcasting & MPMC":"Q: How do I broadcast or use MPMC patterns?\nA: Use MPMC mode for multi-producer/multi-consumer. See concurrency models for details.","what-is-the-aba-problem#What is the ABA Problem?":"The ABA problem is a classic bug in lock-free programming. It occurs when a memory location is changed from value A to B and back to A between two checks, making it appear unchanged to a thread using compare-and-swap (CAS). This can lead to subtle, hard-to-detect errors.How does SP8D prevent ABA?SP8D uses a generation (cycle) tag for each slot. This tag increments every time a slot is reclaimed or wraps around, so even if the slot’s status returns to its original value, the generation tag will be different. This ensures that CAS operations are always safe and reliable.","slot-state-machine--protocol-internals#Slot State Machine & Protocol Internals":"For a complete explanation of the slot state machine—including slot lifecycle, state transitions, atomic operations, fairness, and recovery—see the Slot State Machine documentation.","general#General":"Q: Still stuck or have another question?\nA: Open an issue or check the docs for more details."}},"/guides-and-howtos/troubleshooting":{"title":"SP8D Troubleshooting Guide: Buffer Full, Starvation, Diagnostics","data":{"":"This guide covers persistent buffer full, starvation, unfair access, and\nadvanced diagnostics for SP8D channels. Use the scenarios below to quickly\ndiagnose and resolve common issues.","troubleshooting-scenarios#Troubleshooting Scenarios":"","persistent-buffer-full#Persistent Buffer Full":"Check if your consumer is too slow or your buffer is too small.\nUse diagnostics to identify bottlenecks.\nTry increasing buffer size or optimizing consumer logic.","starvation-or-unfair-access#Starvation or Unfair Access":"Use diagnostics to check for agents that are not making progress.\nReview your concurrency pattern—consider switching to SPSC or MPSC if possible.\nTune buffer size and retry logic.","slot-state-machine-issues#Slot State Machine Issues":"For a complete guide to slot state machine internals—including slot lifecycle, state transitions, fairness, and recovery—see the Slot State Machine documentation.","advanced-diagnostics--mythbusting#Advanced Diagnostics & Mythbusting":"Myth: “Backpressure means data loss.”\nFact: SP8D never drops data silently; you always get a signal and can handle it.\nMyth: “Fairness is automatic in all lock-free systems.”\nFact: Only protocols with explicit fairness mechanisms (like SP8D’s slot state machine) can guarantee it.\nMyth: “Backpressure only happens in slow systems.”\nFact: Backpressure can occur even in high-performance systems during bursts or imbalanced workloads.\nMyth: “Diagnostics are only for debugging.”\nFact: Diagnostics are essential for proactive monitoring and tuning in production.","where-to-go-next#Where to Go Next":"Common Recipes\nChannel API Reference\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/":{"title":"SP8D: Ultra-Low-Latency Lock-Free Channels for JavaScript & Node.js","data":{"":"SP8D is the leading open-source solution for ultra-low-latency, lock-free, real-time messaging and cross-thread communication in JavaScript and Node.js. Built for demanding AI, finance, and multi-agent applications, SP8D delivers blazing-fast, observable, and reliable data transfer for modern web and server environments.\nThe world’s first radically observable, lock-free, bounded protocol for cross-thread communication in browsers — designed for next-generation AI copilots, trading platforms, and multi-agent applications.","what-is-sp8d#What is SP8D?":"The world’s first radically observable, lock-free, bounded protocol for\ncross-thread communication in browsers — designed for next-generation AI\ncopilots, trading platforms, and multi-agent applications.\nSP8D is a breakthrough communication core for demanding front-end and AI workloads:\nBlazing-fast, lock-free, slot-based communication via SharedArrayBuffer and Atomics\nTruly bounded and backpressure-driven, with guaranteed “never drop, never leak, never stall”\nBattle-tested for real-time trading, ML agents, and browser-native concurrency\nRadically observable: live diagnostics, transparency, and no more guessing why your system slowed down\nWhether you’re wiring up AI copilots, streaming market data, or building the next layer of browser-native intelligence—SP8D gives you tools, proof, and performance the rest of the ecosystem can’t match.","instant-hello-world-browsernode#Instant Hello World (Browser/Node)":"Try SP8D instantly in your browser or Node.js with this minimal example.\nimport { createChannel } from \"@sp8d/core\";\nconst { channel } = createChannel({ slots: 8, slotSize: 64 }); // SPSC mode by default\n// Producer\nchannel.send(new Uint8Array([1, 2, 3]));\n// Consumer\nconst msg: Uint8Array | undefined = channel.recv(); // Uint8Array([1, 2, 3])\nconsole.log(msg);\n→ See SP8D Quickstart Recipes for Browser\nWorkers for drop-in examples.","why-sp8d#Why SP8D?":"Tired of slow, memory-leaky, or debugging-nightmare message passing?\nNeed guaranteed low-latency, fairness, and traceability under stress?\nBuilding for regulated, high-stakes domains (finance, AI/ML, ops, browser concurrency)?\nSP8D is designed for you.","where-to-go-next#Where to Go Next":"Minimal Example\nCommon Recipes\nChannel API Reference\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting\nDiagnostics & Benchmarking → Benchmark and observe SP8D live in your production environment.","get-involved-#Get Involved 👋":"Found a bug? Ideas to expand? Want to sponsor SP8D adoption in your stack?\nContribute or open issues — all feedback and help welcome.\nWant to see the roadmap? Check our vision."}},"/introduction/what-is-sp8d":{"title":"What is SP8D? Lock-Free Real-Time Messaging for JavaScript & Node.js","data":{"":"SP8D is a high-performance, lock-free protocol for real-time, observable data transfer between concurrent agents in JavaScript and Node.js. It is designed for AI, finance, and multi-agent applications that demand speed, reliability, and transparency.\nSP8D is a high-performance protocol for moving data instantly, reliably, and observably between concurrent agents in the browser or Node.js. Built for real-time web, AI, and finance, it solves the hardest concurrency problems—without compromise.\nStandard browser messaging APIs like postMessage and\nMessageChannel suffer from unpredictable latency, missed updates,\nand poor debuggability. SP8D is designed to solve these pain points for\ndemanding, real-time applications.","why-not-just-use-postmessage-or-messagechannel#Why Not Just Use postMessage or MessageChannel?":"Slow and unpredictable latency\nOpaque: hard to debug and reason about\nMissed updates and lost messages\nDebugging nightmares","what-makes-sp8d-different#What Makes SP8D Different?":"SP8D offers lock-free, slot-based concurrency, bounded memory, live\ndiagnostics, and built-in recovery—making it uniquely suited for high-stakes,\nreal-time, and multi-agent applications.\nLock-Free, Slot-Based Protocol: Uses atomic operations for true parallelism—no server roundtrips, no event-loop blocking, no lock contention.\nBounded and Predictable: Always a fixed memory footprint, explicit backpressure—no risk of memory leaks or runaway processes.\nSegmented and Scalable: Architected for many producers/consumers, scales linearly with your workload.\nRadically Observable: Live diagnostics for every slot, segment, and operation—see conflicts, errors, and lag in real time.\nBattle-Tested Recovery: Built-in recovery (sweeper) mechanism—survives thread death, browser hiccups, and adversarial loads.\nAI-First and Finance-Ready: Designed for demanding real-time and multi-agent flows, with specific integration points for AI, ML, and analytics.","who-is-sp8d-for#Who Is SP8D For?":"AI Developers: Need agent-to-agent or copilot collaboration, without postMessage pain.\nFintech Engineers: Building ultra-low-latency trading, analytics, or compliance-sensitive UIs.\nWeb Performance Experts: Who know why browser threads are a bottleneck, and want to break free.\nTeams moving past MVP: Where growth, reliability, and observability now matter as much as speed.","when-not-to-use-sp8d#When Not to Use SP8D":"SP8D is not ideal for unbounded message queues, trivial fire-and-forget comms,\nor environments lacking SharedArrayBuffer and\nAtomics support (very old browsers, strict CSP).\nYour app requires unbounded message queues or trivial best-effort “fire and forget” comms.\nYou only have a single event producer and consumer and never expect contention.\nBrowser SharedArrayBuffer and Atomics are not supported (very old browsers, highly restricted CSP).","sp8d-vs-postmessage-messagechannel-and-broadcastchannel#SP8D vs. postMessage, MessageChannel, and BroadcastChannel":"See how SP8D compares to standard browser messaging APIs in terms of\nperformance, reliability, and observability.\nHere’s how SP8D stacks up against common browser messaging APIs:\nFeature\tpostMessage\tMessageChannel\tBroadcastChannel\tSP8D\tLock-free\t❌\t❌\t❌\t✅\tBounded/Backpressure\t❌\t❌\t❌\t✅\tObservable/Diagnostics\t❌\t❌\t❌\t✅\tPredictable Latency\t❌\t❌\t❌\t✅\tMulti-producer/consumer\t🚫 (complex)\t🚫 (complex)\t✅\t✅\t\n❌ = Not supported, 🚫 = Possible but complex","how-it-works#How It Works":"Producers send data to the channel, which relays messages to consumers and\nemits live diagnostics for observability.\nDiagram: SP8D channels enable real-time, observable data flow\nbetween producers and consumers.\n💡 Lock-Free: No thread contention, ever.\n🛡️ Bounded: Never leaks, never stalls.\n🔍 Observable: See every event, live.\nWait-free slot arbitration for zero-contention access (no bottlenecks).\nEfficient and safe message reclamation ensuring no data is ever stuck or lost.\nSegment sharding for scalable concurrency.\nRadical observability through fine-grained, real-time tracking of errors, state, and performance.\nMax compatibility: Browser (WebWorker), Node.js (worker_threads), WASM","where-to-go-next#Where to Go Next":"Minimal Example\nCommon Recipes\nChannel API Reference\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/principles/concurrency-models":{"title":"SP8D Concurrency Models: SPSC, MPSC, MPMC Explained for JavaScript & Node.js","data":{"":"Learn how SP8D enables high-performance, lock-free concurrency in JavaScript and Node.js. This guide covers SPSC, MPSC, and MPMC models, with practical tips for scalable, multi-threaded apps.Master SP8D concurrency models—SPSC, MPSC, and MPMC—for high-performance, lock-free communication in JavaScript and Node.js. This guide compares patterns, use cases, and implementation tips to help you optimize your multi-threaded apps.SP8D supports all major cross-thread concurrency patterns out of the box, so you can pick the right one for your workload—from ultra-low-latency pipelines to scalable, many-agent systems.","quick-reference-table#Quick Reference Table":"Use this table to quickly match your concurrency needs to the right SP8D\nchannel model.\nModel\t# Producers\t# Consumers\tTypical Use Case\tSPSC\t1\t1\tSensor → Processor, UI event, SISO\tMPSC\tN\t1\tMany workers → main aggregator\tMPMC\tN\tM\tMulti-agent, load-balancing, simulation","single-producer-single-consumer-spsc#Single-Producer, Single-Consumer (SPSC)":"SPSC is the simplest and fastest concurrency model—ideal for direct,\none-to-one data flows where throughput and minimal contention are critical.\nFor best practices on handling buffer full, fairness, and lossless delivery in\nSPSC, see\nFairness & Backpressure.\nDiagram: One producer, one consumer. Highest throughput,\nminimal contention.","key-points#Key Points":"Highest throughput, minimal contention.\nZero ambiguity: slots always move forward linearly.\nGreat for: video/audio pipelines, UI events, one-off data flows.\nSPSC is not ideal for fan-in or fan-out scenarios. Use MPSC or MPMC for\nthose patterns.","how-to-use#How to use":"const { channel } = createChannel({ mode: \"SPSC\" });\nSee the SPSC Example →\nLooking for installation or setup? See Quickstart: Installation →","multi-producer-single-consumer-mpsc#Multi-Producer, Single-Consumer (MPSC)":"MPSC lets you aggregate work from many sources into a single target—perfect\nfor logging, worker pools, or parallel data collection.\nLearn how SP8D prevents starvation and ensures fair access in MPSC:\nFairness & Backpressure.\nDiagram: Multiple producers, one consumer. Good for parallel\ndata collection, AI tasks fanning in, worker pool → main thread.","key-points-1#Key Points":"Multiple producers, single sink.\nProducers contend for slots — SP8D’s segments reduce collisions.\nGood for: parallel data collection, AI tasks fanning in to model, worker pool → main thread.\nMPSC is not ideal for multi-consumer or mesh scenarios. Use MPMC for those\npatterns.","how-to-use-1#How to use":"const { channel } = createChannel({ mode: \"MPSC\", segments: 2 });\nNeed a minimal working code sample? See Quickstart: Minimal Example →","multi-producer-multi-consumer-mpmc#Multi-Producer, Multi-Consumer (MPMC)":"MPMC is the most flexible model, supporting many producers and many\nconsumers—ideal for load-balancing, multi-agent systems, or simulations at\nscale.\nHigh-contention MPMC setups require careful fairness and backpressure\nhandling. See\nFairness & Backpressure for\nadvanced scenarios and mitigation strategies.\nDiagram: Many producers, many consumers. True concurrent mesh\nfor multi-agent, load-balancing, or simulation workloads.","key-points-2#Key Points":"True concurrent mesh: many-in, many-out.\nPerfect for multi-agent AIs, trading engines, any \"work distributed among many actors.\"\nSegmentation is critical for high contention/low latency.\nMPMC is not ideal for simple point-to-point or single-sink scenarios. Use\nSPSC or MPSC for those patterns.","how-to-use-2#How to use":"const { channel } = createChannel({ mode: \"MPMC\", segments: 4 });\nWant real-world integration code? See Quickstart: Common Recipes →","how-to-choose#How to Choose?":"Unsure which model to use? Match your use case to the recommended model below.\nFor advanced tuning, fairness, and troubleshooting, see\nFairness & Backpressure.\nYour Need:\tRecommended Model\tPoint-to-point data\tSPSC\tFan-in (best for logging, etc)\tMPSC\tMulti-agent, load balancing\tMPMC","interop--scaling#Interop & Scaling":"Segmentation reduces contention and enables scaling—set segments > 1 for multiple producers or consumers. Map each producerId or consumerId to a segment to further reduce slot collisions.\nLooking for protocol internals or slot state machine details? See Slot State Machine →","code-patterns-in-practice#Code Patterns in Practice":"Choose the right model for your architecture:\nSingle-thread to worker: SPSC\nSeveral AI inferences → UI: MPSC\nMarket sim, multi-copilot: MPMC\nSee integration recipes →","where-to-go-next#Where to Go Next":"Common Recipes\nChannel API Reference\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/principles/fairness-backpressure":{"title":"SP8D Principles: Fairness & Backpressure","data":{"":"Fairness and backpressure are the backbone of robust, lock-free messaging in SP8D. Mastering these concepts ensures your SP8D-powered apps remain fast, reliable, and responsive—even under heavy load or contention.\nSP8D’s approach to fairness and backpressure makes high-performance concurrency “just click.” This page will show you how and why.","what-are-fairness--backpressure#What Are Fairness & Backpressure?":"Backpressure occurs when a channel’s buffer is full and cannot accept more data until space is freed. In SP8D, this means a producer must wait or retry if the consumer is too slow.\nReal-world analogy: Like a traffic jam—if the road (buffer) is full, new cars (messages) can’t enter until others exit.\nWhy it matters: Without backpressure handling, you risk data loss, unresponsive apps, or runaway memory usage.\nFairness ensures that all producers and consumers get a fair chance to access the channel, preventing starvation and priority inversion.\nStarvation: When one agent never gets access because others dominate the channel.\nPriority inversion: When a lower-priority agent blocks a higher-priority one.","visualizing-fairness--backpressure#Visualizing Fairness & Backpressure":"","buffer-states#Buffer States":"Diagram: Producers push messages into the buffer and\nconsumers pop them out. Dashed lines represent backpressure (buffer full) or\nwait/retry (buffer empty) signals, ensuring all agents interact fairly with\nthe buffer.\nProducers push messages into the buffer. If the buffer is full, backpressure\nis signaled to producers (dashed lines). Consumers pop messages; if the buffer\nis empty, they must wait or retry. SP8D coordinates access to ensure fairness\nfor all agents.","slot-state-machine-fairness#Slot State Machine Fairness":"For a complete explanation of how SP8D's slot state machine enforces fairness, round-robin access, and prevents starvation—including diagrams, advanced scenarios, and troubleshooting—see the Slot State Machine documentation.","how-sp8d-ensures-fairness--handles-backpressure#How SP8D Ensures Fairness & Handles Backpressure":"SP8D’s protocol is designed to:\nDetect and signal backpressure when a buffer is full or empty.\nEnforce fairness so no agent is starved or unfairly delayed.","quick-reference-signals--actions#Quick Reference: Signals & Actions":"Scenario\tProducer Sees\tConsumer Sees\tWhat to Do\tBuffer Full\tSignal/Exception\t—\tRetry, yield, or wait\tBuffer Empty\t—\tSignal/Exception\tRetry, yield, or wait\tStarvation Detected\tDiagnostics\tDiagnostics\tTune pattern or buffer\t\nIf you see a buffer full error, your consumer may be too slow or your buffer\nsize too small. Consider tuning your workflow or increasing buffer capacity.","best-practices--usage-patterns#Best Practices & Usage Patterns":"","handle-backpressure#Handle backpressure":"Use async iteration or retry logic when a buffer is full.\nfor await (const msg of channel) {\n  try {\n    // process message\n  } catch (err) {\n    // handle error, e.g. diagnostics or retry\n  }\n}\n// or\nwhile (!channel.send(data)) {\n  await new Promise((r: (value: void) => void) => setTimeout(r, 1)); // yield and retry\n  if (channel.diagnostics) {\n    console.log(channel.diagnostics()); // inspect buffer state\n  }\n}","monitor-diagnostics#Monitor diagnostics":"Use SP8D’s diagnostics to spot fairness or backpressure issues early.\nif (channel.diagnostics) {\n  const diag = channel.diagnostics();\n  if ((diag as { starvation?: boolean }).starvation) {\n    console.warn(\"Potential starvation detected:\", diag);\n  }\n}\nTune buffer size: Match your buffer size to your workload for optimal throughput.\nPattern selection: Choose the right concurrency model (SPSC, MPSC, MPMC) for your use case.\nUse diagnostics and live monitoring to catch fairness or backpressure issues\nbefore they impact production.\nSee: Common Recipes, Concurrency Models","what-to-do#What To Do":"Do\nMonitor for buffer full/empty signals and respond appropriately.\nUse diagnostics to detect and resolve fairness issues.\nTune your buffer size and concurrency pattern for your workload.","what-to-avoid#What To Avoid":"Don't\nIgnore repeated buffer full/empty signals.\nAssume fairness is automatic in all concurrency models—verify with diagnostics.\nOverlook the impact of slow consumers or producers.","troubleshooting-what-if-things-go-wrong#Troubleshooting: What If Things Go Wrong?":"For in-depth troubleshooting scenarios—including persistent buffer full,\nstarvation, and advanced diagnostics—see the SP8D Troubleshooting\nGuide.","advanced-scenarios-fairness--backpressure-in-the-real-world#Advanced Scenarios: Fairness & Backpressure in the Real World":"Explore how SP8D handles challenging, real-world concurrency and contention scenarios that go beyond the basics.","multi-producer-multi-consumer-mpmc-fairness#Multi-Producer, Multi-Consumer (MPMC) Fairness":"In high-contention MPMC setups, multiple producers and consumers may compete for buffer slots, risking unfairness or starvation.\n// Simulate multiple producers/consumers\nconst NUM_PRODUCERS = 8;\nconst NUM_CONSUMERS = 8;\n// ...channel setup...\n// Each producer/consumer runs in its own thread or worker\nSP8D’s slot state machine ensures round-robin access, so no producer or\nconsumer can monopolize the buffer—even under heavy contention.","bursty-workloads--buffer-thrashing#Bursty Workloads & Buffer Thrashing":"Bursty traffic can cause the buffer to oscillate rapidly between full and empty, increasing the risk of backpressure and dropped throughput.\n// Producer sends bursts of messages\nfor (let i = 0; i < 1000; i++) {\n  channel.send(burstData());\n  if (i % 100 === 0) await sleep(10); // simulate burst pause\n}\nTune buffer size to absorb bursts, and use diagnostics to monitor for repeated\nbackpressure signals. Consider smoothing input if possible.","starvation-edge-cases#Starvation Edge Cases":"Pathological scheduling or unlucky timing can cause one agent to be starved, even in a fair system.\n// One slow consumer, many fast producers\nwhile (true) {\n  if (channel.hasData()) {\n    process(channel.receive());\n    await sleep(100); // slow consumer\n  }\n}\nUse diagnostics to detect starvation (e.g., one agent not making progress).\nConsider rebalancing workloads or increasing consumer count.","priority-inversion--mitigation#Priority Inversion & Mitigation":"A low-priority agent can block a high-priority one if not managed carefully.\n// High-priority and low-priority producers\nif (isHighPriority) {\n  // try to send first, or use a separate channel\n}\nUse separate channels for different priorities, or implement a priority-aware\nscheduler on top of SP8D if needed.","mixed-concurrency-patterns#Mixed Concurrency Patterns":"Combining SPSC and MPMC channels in a pipeline can introduce subtle fairness or backpressure issues.\n// SPSC for stage 1, MPMC for stage 2\nconst stage1 = createSPSC();\nconst stage2 = createMPMC();\n// ...pipeline setup...\nMonitor each stage independently. Use diagnostics to ensure no stage becomes a\nbottleneck or source of unfairness.","anti-patterns--what-to-avoid#Anti-Patterns & What to Avoid":"Relying on buffer size alone to solve fairness or backpressure.\nIgnoring diagnostics or repeated backpressure signals.\nUsing a single MPMC channel for all traffic when separation by priority or stage would be clearer.","key-takeaways#Key Takeaways":"SP8D’s fairness and backpressure mechanisms are robust even in advanced, real-world scenarios.\nDiagnostics are your best tool for detecting and resolving subtle issues.\nDesign your channel topology and buffer sizes with your workload’s contention and burstiness in mind.","where-to-go-next#Where to Go Next":"Channel API Reference\nCommon Recipes\nProtocol Architecture Overview\nFAQ & Troubleshooting"}},"/protocol-internals/architecture-overview":{"title":"SP8D Protocol Internals: Architecture Overview","data":{"":"SP8D’s protocol internals are the foundation for its lock-free, ultra-low-latency messaging. This page provides a concise, visual, and practical overview of how the protocol works under the hood, so you can confidently build, debug, or extend SP8D-powered systems.\nSP8D delivers lock-free, ultra-low-latency, and observable messaging for demanding AI, finance, and multi-agent applications—outperforming legacy approaches like postMessage.\nThis page is for advanced users, implementers, and contributors who want to\nunderstand the inner workings of SP8D. It provides a high-level, visual, and\nnarrative-driven overview of the protocol’s architecture and data flow.","what-youll-learn#What you'll learn":"How SP8D’s protocol architecture enables lock-free, ultra-low-latency\nmessaging\nThe role and lifecycle of each core component\nHow observability and robustness are built in\nWhere to go for deep dives and advanced troubleshooting\nRead this after the Quickstart, before diving into protocol internals or\ndebugging edge cases.","architecture-at-a-glance#Architecture at a Glance":"SP8D powers real-time, multi-agent communication in browser-based AI copilots,\nensuring fairness and traceability under load.\nDiagram: SP8D protocol architecture. See legend below for numbered\ncomponents.\nLegend:\nProducer: Sends data/messages into the channel\nChannel: Lock-free protocol core, manages slots and state transitions\nSlot Array: Shared memory buffer (SharedArrayBuffer) divided into slots\nConsumer: Receives data/messages from the channel\nDiagnostics: (Optional) Observes, monitors, and reports channel health","key-components#Key Components":"SP8D’s architecture is built from five core components:\nComponent\tDescription\tWhy it matters / Pitfalls\tLearn more\tProducer\tSends data/messages into the channel\tEntry point for all data; incorrect usage can cause stalls\tQuickstart\tChannel\tLock-free protocol core, manages slots and state transitions\tEnsures safety and performance; misconfiguration can cause contention\tSlot State Machine\tSlot Array\tShared memory buffer (SharedArrayBuffer) divided into slots\tCore of lock-free design; buffer sizing is critical\tGen-Cycle Byte\tConsumer\tReceives data/messages from the channel\tMust keep up to avoid lag/backpressure\tFairness & Backpressure\tDiagnostics\tOptional: observes, monitors, and reports channel health\tEnables live debugging and recovery\tDiagnostics FAQ","protocol-workflow-step-by-step#Protocol Workflow: Step-by-Step":"How a message moves through SP8D:\nDiagram: Protocol workflow: each step from producer claim to consumer\nreclaim, with diagnostics observing state transitions.\nEach step is managed by atomic operations to guarantee safety and performance\nunder concurrency.\nProducer claims a free slot in the shared buffer.\nWhat could go wrong? Buffer full, no slots available. \nSP8D:\n Backpressure/fairness logic prevents starvation.\nProducer writes data and marks the slot as ready.\nWhat could go wrong? Partial writes, race conditions. \nSP8D:\n Atomic state transitions guarantee safety.\nChannel manages state transitions and ensures lock-free handoff.\nWhat could go wrong? State corruption. SP8D: Protocol\nenforces valid transitions only.\nConsumer detects ready slot, reads data, and marks slot as reclaimed.\nWhat could go wrong? Consumer lag, missed messages. \nSP8D:\n Diagnostics and lag stats help detect issues.\nDiagnostics (optional) observes slot states, throughput, and errors in real time.","slot-state-machine#Slot State Machine":"For a complete deep dive into slot lifecycle, state transitions, atomic operations, and recovery—including advanced scenarios and best practices—see the Slot State Machine documentation.","observability--diagnostics#Observability & Diagnostics":"Monitor, debug, and optimize in real time:\nSP8D’s diagnostics enable live monitoring and recovery in high-frequency\ntrading and regulated environments.\nSP8D is designed for radical observability. The diagnostics module can be attached to any channel to monitor:\nSlot usage and state\nThroughput (messages/sec)\nConsumer lag\nErrors and conflicts\nimport { createChannel, createChannelDiagnostics } from \"@sp8d/core\";\nconst { channel } = createChannel({ slots: 16, slotSize: 64 });\nconst diagnostics = createChannelDiagnostics(channel, 100);\ndiagnostics.onUpdate((stats) => {\n  console.log(\"SP8D Stats:\", stats);\n});\ndiagnostics.start();\nLive diagnostics help you detect stuck slots, backpressure, and concurrency\nissues before they impact production.\nShow sample diagnostics output\n{\n  \"used\": 2,\n  \"throughput\": 1200,\n  \"consumerLag\": 0,\n  \"errors\": 0,\n  \"conflicts\": 0,\n  \"reclaimed\": 1\n}\nUse createChannelDiagnostics(channel, intervalMs) to monitor any channel in real time.","edge-cases--robustness#Edge Cases & Robustness":"SP8D is designed for real-world reliability:\nStuck slots: Automatic sweeper and diagnostics detect and recover.\nHow to detect: Diagnostics show non-zero used with no throughput.\nHow to recover: Sweeper reclaims stuck slots; manual intervention rarely\nneeded.\nReclaim races: Protocol ensures only one consumer can reclaim a slot.\nHow to detect: Diagnostics may show conflicts.\nHow to recover: Protocol prevents double-reclaim; review consumer logic\nif persistent.\nFull/empty buffer: Backpressure and fairness mechanisms prevent starvation.\nHow to detect: Diagnostics show high used or consumerLag.\nHow to recover: Tune buffer size or consumer speed; see Fairness & Backpressure.\nFor implementation details, see sp8d-core.ts and sp8d-diagnostics.ts.","practical-example-mapping-code-to-architecture#Practical Example: Mapping Code to Architecture":"See the protocol in action. Try this in your project or in the SP8D live test harness:\nimport { createChannel } from \"@sp8d/core\";\nconst { channel } = createChannel({ slots: 8, slotSize: 64 });\nchannel.send(new Uint8Array([1, 2, 3]));\nconst msg = channel.recv();\nDiagram: Step-by-step: (1) Channel creation, (2) Producer action, (3)\nConsumer action.","where-to-go-next#Where to Go Next":"Channel API Reference\nCommon Recipes\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/protocol-internals/gen-cycle-byte":{"title":"SP8D Protocol Internals: Gen-Cycle Byte (Placeholder)","data":{"":"Content coming soon."}},"/protocol-internals/slot-state-machine":{"title":"SP8D Protocol Internals: Slot State Machine","data":{"":"SP8D’s slot state machine is the engine that powers its lock-free, high-performance message passing. This page provides a deep, practical, and visual guide to the slot lifecycle, state transitions, fairness, and recovery—essential for advanced users, implementers, and anyone extending or debugging the protocol.\nWho should read this? Advanced users, protocol implementers, and\nanyone debugging or extending SP8D internals. This page is your canonical, up-to-date\nreference for the slot state machine: the core of SP8D’s lock-free protocol.","quick-reference-slot-states--transitions#Quick Reference: Slot States & Transitions":"State\tCode Value\tDescription\tAllowed Transitions\tAtomic Operation\tEmpty\t0\tSlot is available for claim\t→ Claimed\tCAS (Producer)\tClaimed\t1\tSlot is being written/read\t→ Ready, → Empty\tCAS (Producer/Consumer/Sweeper)\tReady\t2\tSlot contains a message\t→ Claimed\tCAS (Consumer)\t\nCAS: Compare-and-swap via Atomics.compareExchange\nGeneration Tag: Incremented on reclaim/wraparound to prevent\nABA problems and\nenables safe wraparound ABA","what-is-a-slot#What is a Slot?":"A slot is a fixed-size region in the shared buffer that holds a single message. Each slot has:\nStatus: Empty, Claimed, or Ready\nGeneration (Cycle) Tag: Prevents ABA problems and enables safe wraparound\nClaim Timestamp: For diagnostics and recovery\nPayload: The actual message data","slot-lifecycle--state-transitions#Slot Lifecycle & State Transitions":"Diagram: Slot state machine: transitions between Empty,\nClaimed, and Ready, with atomic operations and sweeper recovery.","visual-message-flow-through-the-slot-state-machine#Visual: Message Flow Through the Slot State Machine":"Diagram: Step-by-step message flow: producer claims and\nwrites, consumer claims and reads, sweeper reclaims if needed.","step-by-step-state-transitions-in-code#Step-by-Step: State Transitions in Code":"Below is a simplified TypeScript walkthrough of the slot state machine, based on the actual sp8d-core.ts implementation:\n// Pseudocode for slot state transitions\nfunction producerClaim(slot) {\n  // Atomically claim an empty slot\n  if (Atomics.compareExchange(slot.status, 0, 1) === 0) {\n    // Write payload, set ready\n    slot.payload = ...;\n    Atomics.store(slot.status, 2); // Ready\n  }\n}\nfunction consumerClaim(slot) {\n  // Atomically claim a ready slot\n  if (Atomics.compareExchange(slot.status, 2, 1) === 2) {\n    // Read payload, mark empty and increment generation\n    const data = slot.payload;\n    slot.generation++;\n    Atomics.store(slot.status, 0); // Empty\n    return data;\n  }\n}\nfunction sweeperReclaim(slot, now) {\n  // If slot is stuck in Claimed too long, reclaim\n  if (slot.status === 1 && now - slot.claimTimestamp > sweepTimeoutMs) {\n    slot.generation++;\n    Atomics.store(slot.status, 0); // Empty\n    // Update diagnostics\n  }\n}\nAlways use atomic operations for state transitions. Never write directly to\nstatus except via Atomics.","state-definitions#State Definitions":"Empty (STATUS_EMPTY = 0): Slot is available for a producer to claim.\nClaimed (STATUS_CLAIMED = 1): Slot is being written (by producer) or read (by consumer). No other agent may access.\nReady (STATUS_READY = 2): Slot contains a message, ready for a consumer to claim.","atomic-operations--fairness#Atomic Operations & Fairness":"Claiming a slot: Producers and consumers use Atomics.compareExchange to move a slot from Empty→Claimed or Ready→Claimed, ensuring lock-free, wait-free access.\nGeneration Tag: Incremented on each wraparound or reclaim, preventing stale reads/writes and enabling robust recovery.\nHead/Tail Pointers: Each segment tracks its own head (producer) and tail (consumer) for round-robin fairness.","sweeper-automatic-recovery#Sweeper: Automatic Recovery":"If a slot is stuck in Claimed (e.g., a thread dies mid-operation), the sweeper detects and reclaims it after a timeout (sweepTimeoutMs):\nIncrements generation tag\nMarks slot as Empty\nUpdates diagnostics (reclaimed, errors)\nWithout the sweeper, a single stuck thread could permanently block a slot,\nreducing throughput and breaking fairness.","visual-slot-array-anatomy#Visual: Slot Array Anatomy":"Diagram: SP8D segment ring buffer. Head\npoints to the next slot to write, Tail to the next slot to\nread. Slots contain status, generation, timestamp, and payload.","best-practices--gotchas#Best Practices & Gotchas":"Never skip status transitions: Always use atomic CAS for state changes.\nMonitor diagnostics: High conflicts or reclaimed counts may indicate contention or stuck agents.\nTune sweepTimeoutMs: Too low may cause false reclaims; too high may delay recovery.\nUse generation tags: Always check generation if implementing custom consumers/producers.","advanced-scenarios-multi-segment-mpmc-and-contention#Advanced Scenarios: Multi-Segment, MPMC, and Contention":"Multi-Segment Scaling: Each segment is an independent ring buffer, enabling scalable MPSC/MPMC patterns. Producers and consumers are mapped to segments for load balancing.\nContention Handling: High contention is mitigated by round-robin head/tail pointers and atomic slot claims. Monitor conflicts in diagnostics to detect hotspots.\nFairness: The protocol ensures round-robin fairness by advancing head/tail pointers per segment. Starvation is prevented by the sweeper and diagnostics.\n// Example: Mapping producer/consumer IDs to segments\nconst segment = segments[agentId % segments.length];\n// Each agent operates on its assigned segment for reduced contention\nFor high-throughput workloads, increase the number of segments to reduce\ncontention and improve fairness.","troubleshooting#Troubleshooting":"Stuck slots: Check for high reclaimed or errors in diagnostics.\nStarvation: Ensure all agents are making progress; use diagnostics to detect lagging segments.\nProtocol violations: Use .validate() to check for invalid slot states or generations.","troubleshooting--debugging-checklist#Troubleshooting & Debugging Checklist":"Stuck slots: Check diagnostics for high reclaimed or errors. Use .validate() to inspect slot states.\nStarvation: Ensure all agents are making progress; lagging segments may indicate contention or misconfiguration.\nProtocol violations: Use .validate() and review slot generation tags for inconsistencies.\nPerformance issues: Monitor conflicts and tune segment count and sweepTimeoutMs.\nCustom extensions: Always use atomic operations and check generation tags when implementing custom logic.\nUse the diagnostics API and .validate() method regularly during development\nand in production monitoring.","sweeper--recovery-flowchart-and-checklist#Sweeper & Recovery: Flowchart and Checklist":"Diagram: Sweeper flowchart: detects stuck slots and reclaims\nthem after timeout.\nRecovery Checklist:\nMonitor diagnostics for high reclaimed or errors counts\nTune sweepTimeoutMs for your workload\nEnsure generation tags increment on reclaim\nValidate slot state after recovery (use .validate())\nSetting sweepTimeoutMs too low can cause false reclaims; too high can delay\nrecovery. Always test with your real workload.","reference-implementation-annotated-code#Reference Implementation: Annotated Code":"See the canonical implementation in sp8d-core.ts:\n// Example: Producer claim logic (simplified)\nif (Atomics.compareExchange(slot.status, STATUS_EMPTY, STATUS_CLAIMED) === STATUS_EMPTY) {\n  // Write payload, set ready\n  slot.payload = ...;\n  Atomics.store(slot.status, STATUS_READY);\n}\n// Example: Consumer claim logic (simplified)\nif (Atomics.compareExchange(slot.status, STATUS_READY, STATUS_CLAIMED) === STATUS_READY) {\n  // Read payload, mark empty and increment generation\n  const data = slot.payload;\n  slot.generation++;\n  Atomics.store(slot.status, STATUS_EMPTY);\n}","where-to-go-next#Where to Go Next":"Protocol Architecture Overview\nGen-Cycle Byte\nChannel API Reference\nCommon Recipes\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/quickstart/common-recipes":{"title":"SP8D Recipes: Integration Patterns for JavaScript & Node.js","data":{"":"SP8D’s common recipes are your practical, copy-paste guide to integrating high-performance channels into real-world JavaScript and Node.js apps. This page provides actionable patterns for browser, Node.js, and AI/ML workflows, with diagrams and troubleshooting tips to help you build robust, scalable systems fast.\nUnlock SP8D’s superpowers: copy-paste these patterns to integrate channels across workers, threads, AI loops, and dashboards. Each recipe below is ready to use and includes a visual or explanation to help you understand the data flow and integration points.","pattern-selection-guide#Pattern Selection Guide":"Use Case\tPattern\tWhen to Use\tRecipe Link\tMain thread ↔ Web Worker (browser)\tSPSC/SPSC\tOne producer, one consumer, browser\tBrowser Recipe\tMain thread ↔ Worker (Node.js)\tSPSC/SPSC\tOne producer, one consumer, Node.js\tNode.js Recipe\tMultiple producers/consumers\tMPSC/MPMC\tScale out, reduce contention\tMultiplexing\tAI/ML model integration\tAsync\tOffload to model worker, async flows\tAI/ML Recipe\tDiagnostics & monitoring\tAny\tDebug, monitor, tune\tDiagnostics\tBackpressure handling\tAny\tBuffer full, retry, async\tBackpressure","quick-reference-common-patterns#Quick Reference: Common Patterns":"SPSC (Single-Producer, Single-Consumer): Fastest, simplest, use for 1:1 thread comms.\nMPSC/MPMC (Multi-Producer/Consumer): Use for scaling, fairness, and contention reduction.\nAsync/AI/ML: Use async iteration and workers for model inference or event-driven flows.\nDiagnostics: Always monitor stats in staging/production for best results.\nBackpressure: Always handle buffer full/empty signals to avoid data loss or stalls.","in-a-browser-main-thread-to-worker#In a Browser (Main Thread to Worker)":"This pattern enables high-performance, zero-copy communication between your main thread and a Web Worker. The main thread creates the channel and buffer, transfers it to the worker,\nand both communicate through the shared channel.\nRequires SharedArrayBuffer support in your browser.\nDiagram: Browser: main thread and worker communicate via a\nshared SP8D channel.\nimport { createChannel } from \"@sp8d/core\";\nconst { channel, buffer } = createChannel({ slots: 16, slotSize: 32 });\nconst worker = new Worker(\"worker.js\");\nworker.postMessage(buffer, [buffer]);\nchannel.send(new Uint8Array([99, 100, 101]));\nimport { attachChannel } from \"@sp8d/core\";\nself.onmessage = (e: MessageEvent<SharedArrayBuffer>) => {\n  const channel = attachChannel(e.data);\n  const msg = channel.recv();\n  console.log(\"Worker received:\", msg); // Uint8Array([99, 100, 101])\n};","nodejs-with-worker_threads#Node.js with worker_threads":"This recipe shows how to use SP8D for fast, lock-free communication between Node.js worker threads. The main thread creates the channel and buffer, passes it to the worker, and\nboth communicate through the shared channel.\nRequires Node.js 18+ and worker_threads.\nDiagram: Node.js: main thread and worker communicate via a\nshared SP8D channel.\nimport { createChannel } from \"@sp8d/core\";\nimport { Worker } from \"worker_threads\";\nconst { channel, buffer } = createChannel({ slots: 32, slotSize: 32 });\nconst worker = new Worker(\"./worker.js\", { workerData: buffer });\nchannel.send(new Uint8Array([123]));\nimport { workerData } from \"worker_threads\";\nimport { attachChannel } from \"@sp8d/core\";\nconst channel = attachChannel(workerData);\nconst msg = channel.recv();\nconsole.log(\"Worker received:\", msg); // Uint8Array([123])","multiplexing-multiple-producers-one-or-many-consumers#Multiplexing: Multiple Producers, One or Many Consumers":"This pattern enables scalable, concurrent communication by using segments or multiple channels. Each producer/consumer pair can be in its own worker.\nDiagram: Multiplexing: multiple producers and consumers with\na segmented SP8D channel.\nEach producer and consumer can operate in its own thread or worker, mapped to\nsegments for fair sharing and reduced contention.\n// In each producer thread:\nchannel.send(new Uint8Array([myProducerId]));\n// In each consumer thread:\nwhile (true) {\n  const msg = channel.recv();\n  if (msg) process(msg);\n}\nFor fair sharing and less contention, map producer/consumer IDs to segments using (id % segments) when creating the channel.","integrating-with-ml-or-ai-model-workers#Integrating with ML or AI Model Workers":"This recipe demonstrates how to use SP8D for efficient, async message passing to and from ML/AI model workers. The main thread sends data to the worker, which processes it (e.g., with an ML\nmodel) and can optionally send results back.\nDiagram: AI/ML integration: main thread sends data to a\nworker for model inference via SP8D channel.\nReplace runMyMLModel with your own model inference function.\nimport { attachChannel } from \"@sp8d/core\";\nlet channel;\nself.onmessage = (e) => {\n  channel = attachChannel(e.data);\n};\nasync function processMessages() {\n  while (true) {\n    const msg = await channel.recvAsync(); // waits for a message\n    const result = await runMyMLModel(msg); // user-defined\n    // Optionally, send result back via another channel\n  }\n}\nprocessMessages();","using-diagnostics--stats#Using Diagnostics & Stats":"Monitor health and performance in real time with SP8D diagnostics.\nimport { createChannel, createChannelDiagnostics } from \"@sp8d/core\";\nconst { channel } = createChannel({ slots: 16, slotSize: 64 });\nconst diagnostics = createChannelDiagnostics(channel, 100);\ndiagnostics.onUpdate((stats) => {\n  console.log(\"SP8D Stats:\", stats);\n});\ndiagnostics.start();\nStats include: .used (msgs in flight), .throughput\n(msgs/sec), .consumerLag, .errors,\n.conflicts, .reclaimed.","handling-backpressure-full-buffer#Handling Backpressure (Full Buffer)":"This pattern shows how to handle cases where the buffer is full and the producer must wait or retry.\n// Producer waits if buffer is full\nconst payload = createPayload();\nwhile (!channel.send(payload)) {\n  // Buffer is full, wait a bit or drop/log as needed\n  await new Promise((r) => setTimeout(r, 1));\n}\nIf the buffer is full, the producer must wait, retry, or drop messages as\nappropriate for your workload.","common-pitfalls--troubleshooting#Common Pitfalls & Troubleshooting":"Buffer full, send fails: Always check the return value of\nsend() and handle backpressure (see\nBackpressure).\nWrong concurrency mode: Use SPSC for 1:1, MPSC/MPMC for\nscaling. Mismatched mode can cause errors.\nSharedArrayBuffer issues: Ensure browser/Node.js supports\nit and transfer buffers correctly.\nDiagnostics not enabled: Use diagnostics in staging to\ncatch issues early.\nAsync gotchas: Use sendAsync and\nrecvAsync for non-blocking flows; avoid busy-wait in\nproduction.\nSegment mapping: For fairness, map IDs to segments using\nid % segments.\nFor advanced troubleshooting, see the SP8D Troubleshooting Guide and Slot State Machine Troubleshooting.","where-to-go-next#Where to Go Next":"Minimal Example\nChannel API Reference\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/quickstart/minimal-example":{"title":"SP8D Minimal Example: Lock-Free Messaging in JavaScript & Node.js","data":{"":"This is the fastest way to get a working SP8D channel in your app. For environment requirements, see\nInstallation Requirements →.\nSee how to set up a minimal SP8D channel for real-time, lock-free messaging in JavaScript and Node.js. Copy-paste code for instant high-performance results.","minimal-example-single-producer-single-consumer#Minimal Example: Single Producer, Single Consumer":"The following is the most basic usage: one producer and one consumer,\ncommunicating via a lock-free, bounded channel. For a more complete and\nproduction-ready SPSC example, see\nBasic SPSC Example.","nodejs-typescript#Node.js (TypeScript)":"import { createChannel } from \"@sp8d/core\";\nconst { channel } = createChannel({ slots: 8, slotSize: 64 });\nchannel.send(new Uint8Array([42, 17, 8]));\nconst received: Uint8Array | undefined = channel.recv();\nconsole.log(\"Received:\", received); // Uint8Array([42, 17, 8])\nIf you prefer plain JavaScript, you can use the same code without type\nannotations.","browser-main-thread-to-worker-typescript#Browser: Main Thread to Worker (TypeScript)":"SP8D works seamlessly in browsers, enabling high-performance communication\nbetween the main thread and workers. This example uses two files: one for the\nmain thread, one for the worker. Requires SharedArrayBuffer support in your\nbrowser.\nimport { createChannel } from \"@sp8d/core\";\nconst { channel, buffer } = createChannel({ slots: 8, slotSize: 8 });\nconst worker = new Worker(\"worker.js\");\nworker.postMessage(buffer, [buffer]); // Transfer the SharedArrayBuffer\n// Send a message from main\nchannel.send(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));\nimport { attachChannel } from \"@sp8d/core\";\nself.onmessage = (e: MessageEvent<SharedArrayBuffer>) => {\n  const channel = attachChannel(e.data);\n  const msg: Uint8Array | undefined = channel.recv();\n  console.log(\"Worker received:\", msg); // Should log: Uint8Array([1,2,3,4,5,6,7,8])\n};\nIn this setup, the main thread creates the channel and transfers the buffer to\nthe worker. Both sides can now send and receive messages with zero-copy\nefficiency.\nDiagram: Minimal browser/worker data flow: main thread and\nworker communicate via a shared SP8D channel.","how-it-works#How It Works":"This section summarizes the minimal mechanics behind SP8D’s channel\noperations. For deeper details, see the relevant documentation sections.\ncreateChannel: Allocates a shared ring buffer of slots for your messages, with safety and backpressure.\nsend: Producer claims a slot, writes the payload, and marks it as ready.\nrecv: Consumer waits for a ready slot, reads the data, and frees it.\nAll transitions happen atomically—no locks, ever.","why-use-sp8d-for-minimal-messaging#Why Use SP8D for Minimal Messaging?":"No setup of queues, events, Promise chains, or bounce buffers. Immediate\ndelivery, guaranteed boundedness, lock-free performance. No external\ndependencies beyond modern JS runtime support. Use channel.info()\nor channel.stats() to verify state and health.","try-live#Try Live":"Test SP8D channels interactively in your browser. A live harness is available for experimentation and diagnostics. Open the SP8D Harness →","where-to-go-next#Where to Go Next":"Common Recipes\nChannel API Reference\nProtocol Architecture Overview\nFairness & Backpressure\nFAQ & Troubleshooting"}},"/quickstart/installation":{"title":"Install SP8D: Quickstart Guide for JavaScript & Node.js","data":{"":"Get started with SP8D, the fastest lock-free protocol for cross-thread communication in JavaScript and Node.js. This guide covers requirements, installation, and troubleshooting for high-performance messaging.Welcome to SP8D—the fastest, most reliable way to move data between threads and agents in your app. This guide will help you get SP8D running in your project quickly and correctly, with clear requirements and installation steps.","requirements#Requirements":"Before installing, ensure your environment meets the following requirements. SP8D is designed for modern JavaScript runtimes and does not require any native or C++ dependencies.\nNode.js 18+ or any modern browser supporting SharedArrayBuffer and Atomics.\nBrowser compatibility table →\nIn browsers, cross-origin headers may be required for SharedArrayBuffer.\nCOOP & COEP Headers Explained →\nOnly modern browsers and Node.js 18+ are recommended for SP8D.\nDiagram: Supported and unsupported environments for SP8D.","quickstart-install-sp8d#Quickstart: Install SP8D":"SP8D can be installed using NPM for production use, or loaded via CDN for prototyping and browser demos. The diagram below shows how SP8D integrates into your application stack.\nDiagram: SP8D installation and integration flow: NPM for\nproduction, CDN for prototyping.\nSP8D installation and integration flow: install via NPM for production, or\nimport from CDN for rapid prototyping.","npm-recommended#NPM (Recommended)":"To add SP8D to your project as a dependency, run:\nnpm install @sp8d/core\npnpm add @sp8d/core\nyarn add @sp8d/core\nbun add @sp8d/core","cdnunpkg-for-prototyping#CDN/Unpkg (For Prototyping)":"For quick browser demos or prototyping, you can import SP8D directly from a CDN:\n<script type=\"module\">\n  import {createChannel} from 'https://unpkg.com/@sp8d/core?module';\n</script>","commonjs#CommonJS":"If you are using CommonJS modules (e.g., in older Node.js projects):\nconst { createChannel } = require(\"@sp8d/core\");\nExample package.json\n{\n  \"name\": \"my-sp8d-app\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@sp8d/core\": \"^x.y.z\"\n  }\n}","typescript-support#TypeScript Support":"SP8D is written in TypeScript and ships with complete type definitions. No\nadditional type packages are required. This ensures seamless integration and\ntype safety in TypeScript projects.\nFor a minimal TypeScript example, see: Quickstart: Minimal Example →","smoke-test-verify-your-installation#Smoke Test: Verify Your Installation":"After installation, run this code to verify SP8D is working in your project.\nAfter installation, you can quickly verify that SP8D is working as expected by running the following code in your project:\nimport { createChannel } from \"@sp8d/core\";\nconst { channel } = createChannel({ slots: 4, slotSize: 64 });\nconsole.log(channel.info()); // Prints protocol details\nFor a more detailed walkthrough, see the Quickstart: Minimal Example → or consult the API Reference →.","troubleshooting#Troubleshooting":"If you encounter issues during installation or usage, consider the following.\n“Cannot use SharedArrayBuffer”: Ensure you are in a secure context (https:// with COOP/COEP headers). See FAQ →\nType errors? Make sure you are using Node.js 18+ or a supported bundler.\nStill stuck? Open an issue →","where-to-go-next#Where to Go Next":"Minimal Example\nCommon Recipes\nChannel API Reference\nProtocol Architecture Overview\nFAQ & Troubleshooting"}}}