(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6131],{8594:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/introduction/what-is-sp8d",function(){return r(1889)}])},1889:function(e,n,r){"use strict";r.r(n),r.d(n,{useTOC:function(){return l}});var s=r(5893),t=r(7812),a=r(1937),i=r(9299),o=r(8757),c=r(5956);function l(e){let n={em:"em",...(0,i.a)()};return[{value:"Why Not Just Use postMessage or MessageChannel?",id:"why-not-just-use-postmessage-or-messagechannel",depth:2},{value:"What Makes SP8D Different?",id:"what-makes-sp8d-different",depth:2},{value:"Who Is SP8D For?",id:"who-is-sp8d-for",depth:2},{value:(0,s.jsxs)(s.Fragment,{children:["When ",(0,s.jsx)(n.em,{children:"Not"})," to Use SP8D"]}),id:"when-not-to-use-sp8d",depth:2},{value:"Architecture at a Glance",id:"architecture-at-a-glance",depth:2},{value:"SP8D vs. postMessage, MessageChannel, and BroadcastChannel",id:"sp8d-vs-postmessage-messagechannel-and-broadcastchannel",depth:2},{value:"How It Works",id:"how-it-works",depth:2}]}n.default=(0,t.c)(function(e){let{toc:n=l(e)}=e,r={a:"a",blockquote:"blockquote",em:"em",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.p,{children:"SP8D is a high-performance, lock-free protocol for real-time, observable data transfer between concurrent agents in JavaScript and Node.js. It is designed for AI, finance, and multi-agent applications that demand speed, reliability, and transparency."}),"\n",(0,s.jsx)(r.h1,{children:"What is SP8D? Lock-Free Real-Time Messaging for JavaScript & Node.js"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"SP8D"})," is a high-performance protocol for moving data instantly, reliably, and observably between concurrent agents in the browser or Node.js. Built for real-time web, AI, and finance, it solves the hardest concurrency problems—without compromise."]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(c.U,{type:"warning",title:"Why Not postMessage?",children:(0,s.jsxs)(r.p,{children:["Standard browser messaging APIs like ",(0,s.jsx)("code",{children:"postMessage"})," and"," ","\n",(0,s.jsx)("code",{children:"MessageChannel"})," suffer from unpredictable latency, missed updates,\nand poor debuggability. SP8D is designed to solve these pain points for\ndemanding, real-time applications."]})}),"\n",(0,s.jsx)(r.h2,{id:n[0].id,children:n[0].value}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Slow and unpredictable latency"}),"\n",(0,s.jsx)(r.li,{children:"Opaque: hard to debug and reason about"}),"\n",(0,s.jsx)(r.li,{children:"Missed updates and lost messages"}),"\n",(0,s.jsx)(r.li,{children:"Debugging nightmares"}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:n[1].id,children:n[1].value}),"\n",(0,s.jsx)(c.U,{type:"info",title:"What Sets SP8D Apart?",children:(0,s.jsx)(r.p,{children:"SP8D offers lock-free, slot-based concurrency, bounded memory, live\ndiagnostics, and built-in recovery—making it uniquely suited for high-stakes,\nreal-time, and multi-agent applications."})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Lock-Free, Slot-Based Protocol:"})," Uses atomic operations for true parallelism—no server roundtrips, no event-loop blocking, no lock contention."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Bounded and Predictable:"})," Always a fixed memory footprint, explicit backpressure—no risk of memory leaks or runaway processes."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Segmented and Scalable:"})," Architected for many producers/consumers, scales linearly with your workload."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Radically Observable:"})," Live diagnostics for every slot, segment, and operation—see conflicts, errors, and lag in real time."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Battle-Tested Recovery:"})," Built-in recovery (sweeper) mechanism—survives thread death, browser hiccups, and adversarial loads."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"AI-First and Finance-Ready:"})," Designed for demanding real-time and multi-agent flows, with specific integration points for AI, ML, and analytics."]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:n[2].id,children:n[2].value}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"AI Developers:"})," Need agent-to-agent or copilot collaboration, without postMessage pain."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Fintech Engineers:"})," Building ultra-low-latency trading, analytics, or compliance-sensitive UIs."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Web Performance Experts:"})," Who know why browser threads are a bottleneck, and want to break free."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Teams moving past MVP:"})," Where growth, reliability, and observability now matter as much as speed."]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:n[3].id,children:n[3].value}),"\n",(0,s.jsx)(c.U,{type:"warning",title:"When Not to Use SP8D",children:(0,s.jsxs)(r.p,{children:["SP8D is not ideal for unbounded message queues, trivial fire-and-forget comms,\nor environments lacking ",(0,s.jsx)("code",{children:"SharedArrayBuffer"})," and"," ","\n",(0,s.jsx)("code",{children:"Atomics"})," support (very old browsers, strict CSP)."]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Your app requires unbounded message queues or trivial best-effort “fire and forget” comms."}),"\n",(0,s.jsx)(r.li,{children:"You only have a single event producer and consumer and never expect contention."}),"\n",(0,s.jsx)(r.li,{children:"Browser SharedArrayBuffer and Atomics are not supported (very old browsers, highly restricted CSP)."}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:n[4].id,children:n[4].value}),"\n",(0,s.jsx)(c.U,{type:"info",title:"Architecture Overview",children:(0,s.jsx)(r.p,{children:"SP8D channels use lock-free, slot-based buffers with live diagnostics,\nsupporting multiple producers and consumers for real-time, observable data\nflow."})}),"\n",(0,s.jsx)(o.G,{chart:"%% Diagram: SP8D channel architecture with multiple producers/consumers, slots, and diagnostics\\n%% Accessible description: Multiple producers send data to a lock-free SP8D channel, which uses SharedArrayBuffer and Atomics for slots, and supports multiple consumers and live diagnostics.\\ngraph TD\\n    Producer1(Producer 1)\\n    Producer2(Producer 2)\\n    Channel(SP8D Channel)\\n    Slots(Slots: SharedArrayBuffer + Atomics)\\n    Consumer1(Consumer 1)\\n    Consumer2(Consumer 2)\\n    Diagnostics(Diagnostics)\\n\\n    Producer1 -->|send| Channel\\n    Producer2 -->|send| Channel\\n    Channel -->|recv| Consumer1\\n    Channel -->|recv| Consumer2\\n    Channel --> Slots\\n    Diagnostics -.-> Channel"}),"\n",(0,s.jsx)("sub",{children:(0,s.jsx)(r.p,{children:"SP8D enables multiple producers and consumers to communicate through a\nlock-free, observable channel with live diagnostics."})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:n[5].id,children:n[5].value}),"\n",(0,s.jsx)(c.U,{type:"info",title:"Comparison Table",children:(0,s.jsx)(r.p,{children:"See how SP8D compares to standard browser messaging APIs in terms of\nperformance, reliability, and observability."})}),"\n",(0,s.jsx)(r.p,{children:"Here’s how SP8D stacks up against common browser messaging APIs:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Feature"}),(0,s.jsx)(r.th,{children:"postMessage"}),(0,s.jsx)(r.th,{children:"MessageChannel"}),(0,s.jsx)(r.th,{children:"BroadcastChannel"}),(0,s.jsx)(r.th,{children:"SP8D"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Lock-free"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"✅"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Bounded/Backpressure"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"✅"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Observable/Diagnostics"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"✅"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Predictable Latency"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"❌"}),(0,s.jsx)(r.td,{children:"✅"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Multi-producer/consumer"}),(0,s.jsx)(r.td,{children:"\uD83D\uDEAB (complex)"}),(0,s.jsx)(r.td,{children:"\uD83D\uDEAB (complex)"}),(0,s.jsx)(r.td,{children:"✅"}),(0,s.jsx)(r.td,{children:"✅"})]})]})]}),"\n",(0,s.jsx)("sub",{children:"❌ = Not supported, \uD83D\uDEAB = Possible but complex"}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:n[6].id,children:n[6].value}),"\n",(0,s.jsx)(c.U,{type:"info",title:"How It Works",children:(0,s.jsx)(r.p,{children:"Producers send data to the channel, which relays messages to consumers and\nemits live diagnostics for observability."})}),"\n",(0,s.jsx)(o.G,{chart:"%% Sequence diagram: Producer sends, Channel relays, Consumer receives, Diagnostics observes\\n%% Accessible description: Producer sends data to Channel, Channel relays to Consumer, Diagnostics observes events.\\nsequenceDiagram\\n    participant Producer\\n    participant Channel\\n    participant Consumer\\n    participant Diagnostics\\n\\n    Producer->>Channel: send(data)\\n    Channel->>Consumer: recv()\\n    Channel->>Diagnostics: emit(event)"}),"\n",(0,s.jsx)("sub",{children:(0,s.jsx)(r.p,{children:"SP8D channels enable real-time, observable data flow between producers and\nconsumers."})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(c.U,{type:"tip",title:"Key Features",children:(0,s.jsxs)("ul",{children:[(0,s.jsx)("li",{children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)("b",{children:"\uD83D\uDCA1 Lock-Free:"})," No thread contention, ever."]})}),(0,s.jsx)("li",{children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)("b",{children:"\uD83D\uDEE1️ Bounded:"})," Never leaks, never stalls."]})}),(0,s.jsx)("li",{children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)("b",{children:"\uD83D\uDD0D Observable:"})," See every event, live."]})})]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Lock-free, wait-free slot arbitration (no bottlenecks)"}),"\n",(0,s.jsx)(r.li,{children:"Fast, safe, observable reclamation (never stuck)"}),"\n",(0,s.jsx)(r.li,{children:"Segment sharding for scalable concurrency"}),"\n",(0,s.jsxs)(r.li,{children:["Fine-grained error, state, and performance tracking (",(0,s.jsx)(r.strong,{children:"radical observability"}),")"]}),"\n",(0,s.jsx)(r.li,{children:"Max compatibility: Browser (WebWorker), Node.js (worker_threads), WASM"}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.em,{children:"Last updated: 14 May 2025"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.strong,{children:["Next: ",(0,s.jsx)(r.a,{href:"/quickstart/installation",children:"Install SP8D in your project →"})]})})]})},"/introduction/what-is-sp8d",{filePath:"pages/introduction/what-is-sp8d.mdx",timestamp:1747204101e3,pageMap:a.v,frontMatter:{title:"What is SP8D? Lock-Free Real-Time Messaging for JavaScript & Node.js",description:"Learn what makes SP8D the best lock-free, high-performance protocol for real-time, observable data transfer in JavaScript and Node.js. Ideal for AI, finance, and multi-agent apps.",keywords:["SP8D","what is SP8D","lock-free protocol","real-time data","browser concurrency","AI messaging","Node.js","SharedArrayBuffer","diagnostics","high-performance messaging","parallel programming"],canonical:"https://sp8d.github.io/introduction/what-is-sp8d"},title:"What is SP8D? Lock-Free Real-Time Messaging for JavaScript & Node.js"},"undefined"==typeof RemoteContent?l:RemoteContent.useTOC)},5956:function(e,n,r){"use strict";r.d(n,{U:function(){return c}});var s=r(5893),t=r(512),a=r(5192);let i={default:"\uD83D\uDCA1",error:"\uD83D\uDEAB",info:(0,s.jsx)(a.AV,{className:"_mt-1"}),warning:"⚠️"},o={default:(0,t.Z)("_border-orange-100 _bg-orange-50 _text-orange-800 dark:_border-orange-400/30 dark:_bg-orange-400/20 dark:_text-orange-300"),error:(0,t.Z)("_border-red-200 _bg-red-100 _text-red-900 dark:_border-red-200/30 dark:_bg-red-900/30 dark:_text-red-200"),info:(0,t.Z)("_border-blue-200 _bg-blue-100 _text-blue-900 dark:_border-blue-200/30 dark:_bg-blue-900/30 dark:_text-blue-200"),warning:(0,t.Z)("_border-yellow-100 _bg-yellow-50 _text-yellow-900 dark:_border-yellow-200/30 dark:_bg-yellow-700/30 dark:_text-yellow-200")};function c({children:e,type:n="default",emoji:r=i[n]}){return(0,s.jsxs)("div",{className:(0,t.Z)("nextra-callout _overflow-x-auto _mt-6 _flex _rounded-lg _border _py-2 ltr:_pr-4 rtl:_pl-4","contrast-more:_border-current contrast-more:dark:_border-current",o[n]),children:[(0,s.jsx)("div",{className:"_select-none _text-xl ltr:_pl-3 ltr:_pr-2 rtl:_pr-3 rtl:_pl-2",style:{fontFamily:'"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"'},children:r}),(0,s.jsx)("div",{className:"_w-full _min-w-0 _leading-7",children:e})]})}},8757:function(e,n,r){"use strict";r.d(n,{G:function(){return a}});var s=r(5893),t=r(7294);function a({chart:e}){let n=(0,t.useId)(),[a,i]=(0,t.useState)(""),o=(0,t.useRef)(null),c=function(e){let[n,r]=(0,t.useState)(!1);return(0,t.useEffect)(()=>{let n=new IntersectionObserver(([e])=>{e.isIntersecting&&(n.disconnect(),r(!0))});return n.observe(e.current),()=>{n.disconnect()}},[e]),n}(o);return(0,t.useEffect)(()=>{if(!c)return;let s=document.documentElement,t=new MutationObserver(a);return t.observe(s,{attributes:!0}),a(),()=>{t.disconnect()};async function a(){let t=s.classList.contains("dark")||s.attributes.getNamedItem("data-theme")?.value==="dark",{default:a}=await Promise.all([r.e(6925),r.e(2858)]).then(r.bind(r,2858));try{a.initialize({startOnLoad:!1,securityLevel:"loose",fontFamily:"inherit",themeCSS:"margin: 1.5rem auto 0;",theme:t?"dark":"default"});let{svg:r}=await a.render(n.replaceAll(":",""),e.replaceAll("\\n","\n"),o.current);i(r)}catch(e){console.error("Error while rendering mermaid",e)}}},[e,c]),(0,s.jsx)("div",{ref:o,dangerouslySetInnerHTML:{__html:a}})}},1937:function(e,n,r){"use strict";r.d(n,{v:function(){return s}});let s=[{data:{index:"Home",introduction:"Introduction",quickstart:"Quickstart",principles:"Principles","api-reference":"API Reference","guides-and-howtos":"Guides and How-Tos",examples:"Examples",testHarness:{title:"Test Harness",type:"page",href:"https://harness.sp8d.com",newWindow:!0},contact:{title:"Contact",type:"page",href:"mailto:admin@sp8d.com",newWindow:!0}}},{name:"api-reference",route:"/api-reference",children:[{data:{"channel-api":{title:"Channel API"}}},{name:"channel-api",route:"/api-reference/channel-api",frontMatter:{title:"SP8D Channel API Reference: Lock-Free Messaging for JavaScript & Node.js",description:"Comprehensive SP8D Channel API reference for JavaScript and Node.js. Learn methods, options, diagnostics, troubleshooting, and best practices for lock-free, real-time, high-performance messaging.",keywords:["SP8D API","channel API","JavaScript","Node.js","lock-free messaging","diagnostics","concurrency","high-performance messaging"],canonical:"https://sp8d.github.io/api-reference/channel-api"}}]},{name:"examples",route:"/examples",children:[{data:{"basic-spsc":{title:"Basic SPSC"}}},{name:"basic-spsc",route:"/examples/basic-spsc",frontMatter:{title:"SP8D SPSC Example: Single-Producer Single-Consumer in JavaScript & Node.js",description:"Step-by-step SP8D SPSC example for JavaScript and Node.js. Learn how to implement ultra-low-latency, lock-free single-producer single-consumer channels for high-performance messaging.",keywords:["SP8D example","SPSC","single-producer single-consumer","lock-free queue","JavaScript","Node.js","concurrency","high-performance messaging","parallel programming"],canonical:"https://sp8d.github.io/examples/basic-spsc"}}]},{name:"guides-and-howtos",route:"/guides-and-howtos",children:[{data:{faqs:{title:"FAQs"}}},{name:"faqs",route:"/guides-and-howtos/faqs",frontMatter:{title:"SP8D FAQ: Troubleshooting, Diagnostics & Concurrency in JavaScript & Node.js",description:"Frequently asked questions about SP8D: browser support, diagnostics, backpressure, async iteration, and troubleshooting for high-performance JavaScript and Node.js messaging.",keywords:["SP8D FAQ","troubleshooting","browser support","diagnostics","backpressure","async iteration","concurrency","JavaScript","Node.js","high-performance messaging"],canonical:"https://sp8d.github.io/guides-and-howtos/faqs"}}]},{name:"index",route:"/",frontMatter:{title:"SP8D: Ultra-Low-Latency Lock-Free Channels for JavaScript & Node.js",description:"Discover SP8D, the fastest lock-free, observable protocol for real-time, cross-thread communication in JavaScript and Node.js. Learn features, use cases, and how to get started with high-performance messaging.",keywords:["SP8D","lock-free channels","real-time messaging","AI concurrency","browser communication","SharedArrayBuffer","Atomics","multi-agent","diagnostics","JavaScript","Node.js","high-performance messaging","parallel programming"],canonical:"https://sp8d.github.io/"}},{name:"introduction",route:"/introduction",children:[{data:{"what-is-sp8d":{title:"What is SP8D"}}},{name:"what-is-sp8d",route:"/introduction/what-is-sp8d",frontMatter:{title:"What is SP8D? Lock-Free Real-Time Messaging for JavaScript & Node.js",description:"Learn what makes SP8D the best lock-free, high-performance protocol for real-time, observable data transfer in JavaScript and Node.js. Ideal for AI, finance, and multi-agent apps.",keywords:["SP8D","what is SP8D","lock-free protocol","real-time data","browser concurrency","AI messaging","Node.js","SharedArrayBuffer","diagnostics","high-performance messaging","parallel programming"],canonical:"https://sp8d.github.io/introduction/what-is-sp8d"}}]},{name:"principles",route:"/principles",children:[{data:{"concurrency-models":{title:"Concurrency Models"}}},{name:"concurrency-models",route:"/principles/concurrency-models",frontMatter:{title:"SP8D Concurrency Models: SPSC, MPSC, MPMC Explained for JavaScript & Node.js",description:"Master SP8D concurrency models—SPSC, MPSC, and MPMC—for high-performance, lock-free communication in JavaScript and Node.js. Compare patterns, use cases, and implementation tips to optimize your multi-threaded apps.",keywords:["SP8D concurrency","SPSC","MPSC","MPMC","concurrency models","lock-free","multi-threading","JavaScript","Node.js","high-performance messaging","parallel programming"],canonical:"https://sp8d.github.io/principles/concurrency-models"}}]},{name:"quickstart",route:"/quickstart",children:[{data:{installation:{title:"Installation"},"minimal-example":{title:"Minimal Example"},"common-recipes":{title:"Common Recipes"}}},{name:"common-recipes",route:"/quickstart/common-recipes",frontMatter:{title:"SP8D Recipes: Integration Patterns for JavaScript & Node.js",description:"Common SP8D integration patterns and recipes for JavaScript and Node.js. Learn browser, Node.js, and AI/ML workflows with code samples and diagrams for high-performance messaging.",keywords:["SP8D recipes","integration patterns","JavaScript","Node.js","AI messaging","browser workers","concurrency","high-performance messaging"],canonical:"https://sp8d.github.io/quickstart/common-recipes"}},{name:"installation",route:"/quickstart/installation",frontMatter:{title:"Install SP8D: Quickstart Guide for JavaScript & Node.js",description:"How to install SP8D for ultra-fast, lock-free cross-thread communication in JavaScript and Node.js. Step-by-step requirements, setup, and troubleshooting for high-performance messaging.",keywords:["SP8D installation","quickstart","JavaScript","Node.js","SharedArrayBuffer","Atomics","setup guide","high-performance messaging"],canonical:"https://sp8d.github.io/quickstart/installation"}},{name:"minimal-example",route:"/quickstart/minimal-example",frontMatter:{title:"SP8D Minimal Example: Lock-Free Messaging in JavaScript & Node.js",description:"Minimal working SP8D example for real-time, lock-free messaging in JavaScript and Node.js. Copy-paste code for instant high-performance results.",keywords:["SP8D minimal example","quickstart","JavaScript","Node.js","lock-free messaging","concurrency","high-performance messaging"],canonical:"https://sp8d.github.io/quickstart/minimal-example"}}]}]}},function(e){e.O(0,[7812,2888,9774,179],function(){return e(e.s=8594)}),_N_E=e.O()}]);